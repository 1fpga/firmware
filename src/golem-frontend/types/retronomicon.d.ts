/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/login/github": {
    /**
     * @description Login using GitHub with OAuth2. This will redirect the user to GitHub's login page. If the user accepts the request, GitHub will redirect the user back to the callback URL specified in the OAuth2 configuration.
     *
     * This is not a REST endpoint, but a normal web page.
     */
    get: operations["auth_github_login"];
  };
  "/login/google": {
    /**
     * @description Login using Google with OAuth2. This will redirect the user to GitHub's login page. If the user accepts the request, GitHub will redirect the user back to the callback URL specified in the OAuth2 configuration.
     *
     * This is not a REST endpoint, but a normal web page.
     */
    get: operations["auth_google_login"];
  };
  "/login/patreon": {
    /** @description Login using Patreon with OAuth2. */
    get: operations["auth_patreon_login"];
  };
  "/logout": {
    /** @description Logout the current user. */
    post: operations["auth_logout"];
  };
  "/cores": {
    /** @description List cores. */
    get: operations["cores_cores_list"];
    post: operations["cores_cores_create"];
  };
  "/cores/{core_id}": {
    get: operations["cores_cores_details"];
  };
  "/cores/{core_id}/releases/{release_id}/artifacts": {
    /** @description Get a release's artifact list, including everything except the data itself. */
    get: operations["cores_releases_cores_releases_artifacts_list"];
    /** @description Upload an artifact to a release. This can be done multiple times. The upload will be refused if the user does not have permission to upload artifacts to the release's core. */
    post: operations["cores_releases_cores_releases_artifacts_upload"];
  };
  "/cores/{core_id}/releases": {
    get: operations["cores_releases_cores_releases_list"];
    /** @description Create a release for a core. This does not include any artifacts, which must be uploaded separately. */
    post: operations["cores_releases_cores_releases_create"];
  };
  "/games/{game_id}/artifacts": {
    post: operations["games_games_add_artifact"];
  };
  "/games": {
    get: operations["games_games_list"];
    post: operations["games_games_create"];
  };
  "/games/{game_id}": {
    get: operations["games_games_details"];
    put: operations["games_games_update"];
  };
  "/me": {
    get: operations["me_me"];
  };
  "/me/token": {
    /** @description Create a JWT token for the current logged-in user. */
    post: operations["me_me_token"];
  };
  "/me/update": {
    put: operations["me_me_update"];
  };
  "/platforms": {
    get: operations["platforms_platforms_list"];
    post: operations["platforms_platforms_create"];
  };
  "/platforms/{platform_id}": {
    get: operations["platforms_platforms_details"];
    put: operations["platforms_platforms_update"];
  };
  "/systems": {
    get: operations["systems_systems_list"];
    post: operations["systems_systems_create"];
  };
  "/systems/{id}": {
    get: operations["systems_systems_details"];
  };
  "/tags": {
    /** @description List tags. */
    get: operations["tags_tags"];
    /** @description Create or update a tag. */
    post: operations["tags_tags_create"];
  };
  "/tags/{tag_id}": {
    /** @description Get a tag information (including its description). */
    delete: operations["tags_tags_delete"];
  };
  "/teams/{team_id}/invitation": {
    post: operations["teams_invite"];
  };
  "/teams/{team_id}/invitation/accept": {
    post: operations["teams_invite_accept"];
  };
  "/teams": {
    get: operations["teams_teams"];
    /** @description Create a new team, and make the current user its owner. */
    post: operations["teams_teams_create"];
  };
  "/teams/{team_id}": {
    /** @description Create a new team, and make the current user its owner. */
    put: operations["teams_teams_update"];
    delete: operations["teams_teams_delete"];
  };
  "/teams/{id}": {
    get: operations["teams_teams_details"];
  };
  "/users/check": {
    /** @description Check availability of a username. This is easier and less resource intensive than getting the user's details and checking for 404. */
    post: operations["users_check_username"];
  };
  "/users": {
    /** @description List all users. */
    get: operations["users_users"];
  };
  "/users/{id}": {
    get: operations["users_users_details"];
    /** @description Only root users can update other users. */
    put: operations["users_users_update"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    CoreCreateResponse: {
      /** Format: int32 */
      id: number;
      slug: string;
    };
    CoreCreateRequest: {
      slug: string;
      name: string;
      description: string;
      links: {
        [key: string]: string;
      };
      metadata: {
        [key: string]: unknown;
      };
      system: components["schemas"]["IdOrSlug"];
      owner_team: components["schemas"]["IdOrSlug"];
    };
    /** @description Either an ID (integer) or a slug (string). */
    IdOrSlug: number | string;
    CoreDetailsResponse: {
      /** Format: int32 */
      id: number;
      slug: string;
      name: string;
      description: string;
      links: {
        [key: string]: string;
      };
      metadata: {
        [key: string]: unknown;
      };
      system: components["schemas"]["SystemRef"];
      owner_team: components["schemas"]["TeamRef"];
    };
    SystemRef: {
      /** Format: int32 */
      id: number;
      slug: string;
    };
    TeamRef: {
      /** Format: int32 */
      id: number;
      name: string;
      slug: string;
    };
    CoreListItem: {
      /** Format: int32 */
      id: number;
      slug: string;
      name: string;
      system: components["schemas"]["SystemRef"];
      owner_team: components["schemas"]["TeamRef"];
      latest_release?: components["schemas"]["CoreReleaseRef"] | null;
    };
    CoreReleaseRef: {
      /** Format: int32 */
      id: number;
      version: string;
      /** @description Whether this release is a prerelease. Prereleases are not shown by default. */
      prerelease: boolean;
      /** @description Whether this release was yanked. Yanked releases are not shown by default. */
      yanked: boolean;
      /**
       * Format: int64
       * @description Date the release was uploaded to the server, in seconds since UNIX EPOCH.
       */
      date_released: number;
      /** @description Which platform was this release made for. */
      platform: components["schemas"]["PlatformRef"];
    };
    PlatformRef: {
      /** Format: int32 */
      id: number;
      slug: string;
      name: string;
    };
    CoreReleaseArtifactListItem: {
      /** Format: int32 */
      id: number;
      filename: string;
      download_url: string;
      mime_type: string;
      /** Format: int64 */
      created_at: number;
      ref: components["schemas"]["ArtifactRef"];
    };
    ArtifactRef: {
      /** @description Optional URL to download this artifact. */
      download_url?: string | null;
      /** Format: uint32 */
      size?: number | null;
      md5?: components["schemas"]["HexString"] | null;
      sha1?: components["schemas"]["HexString"] | null;
      sha256?: components["schemas"]["HexString"] | null;
    };
    /** @example 01020304 */
    HexString: string;
    /** @description The result of creating a new artifact. */
    ArtifactCreateResponse: {
      /**
       * Format: int32
       * @description The ID of the artifact.
       */
      id: number;
      /** @description A URL to download it if there was an uploaded file. */
      url?: string | null;
    };
    CoreReleaseCreateResponse: {
      /** Format: int32 */
      id: number;
    };
    CoreReleaseCreateRequest: {
      version: string;
      notes: string;
      /** Format: int64 */
      date_released?: number | null;
      prerelease: boolean;
      links: {
        [key: string]: string;
      };
      metadata: {
        [key: string]: unknown;
      };
      platform: components["schemas"]["IdOrSlug"];
    };
    CoreReleaseListItem: {
      core: components["schemas"]["CoreRef"];
      uploader: components["schemas"]["UserRef"];
      /** Format: int32 */
      id: number;
      version: string;
      /** @description Whether this release is a prerelease. Prereleases are not shown by default. */
      prerelease: boolean;
      /** @description Whether this release was yanked. Yanked releases are not shown by default. */
      yanked: boolean;
      /**
       * Format: int64
       * @description Date the release was uploaded to the server, in seconds since UNIX EPOCH.
       */
      date_released: number;
      /** @description Which platform was this release made for. */
      platform: components["schemas"]["PlatformRef"];
    };
    CoreRef: {
      /** Format: int32 */
      id: number;
      slug: string;
      name: string;
    };
    UserRef: {
      /** Format: int32 */
      id: number;
      username: string;
    };
    /** @description The expected response of an end point that does not return anything. */
    Ok: null;
    GameAddArtifactRequest: {
      /** @description Its content type. */
      mime_type: string;
      /**
       * Format: int32
       * @description Size of the file in bytes. Files cannot be larger than 20MB.
       */
      size: number;
      /** @description MD5 checksum of the file, in hexadecimal. */
      md5?: components["schemas"]["HexString"] | null;
      /** @description SHA1 checksum of the file, in hexadecimal. */
      sha1?: components["schemas"]["HexString"] | null;
      /** @description SHA256 checksum of the file, in hexadecimal. */
      sha256?: components["schemas"]["HexString"] | null;
    };
    GameCreateResponse: {
      /** Format: int32 */
      id: number;
    };
    GameCreateRequest: {
      name: string;
      description: string;
      short_description: string;
      /** Format: int32 */
      year: number;
      publisher: string;
      developer: string;
      links: {
        [key: string]: string;
      };
      system: components["schemas"]["IdOrSlug"];
      /** Format: int32 */
      system_unique_id: number;
    };
    GameDetails: {
      /** Format: int32 */
      id: number;
      name: string;
      description: string;
      short_description: string;
      /** Format: int32 */
      year: number;
      publisher: string;
      developer: string;
      links: unknown;
      /** Format: int32 */
      system_unique_id: number;
      system: components["schemas"]["SystemRef"];
    };
    GameListItemResponse: {
      /**
       * Format: int32
       * @description The identifier for the game, this is unique for ALL games.
       */
      id: number;
      /** @description The name of the game. Does not include any `[]` tags. */
      name: string;
      /** @description A short description of the game. */
      short_description: string;
      /**
       * Format: int32
       * @description The year the game was released.
       */
      year: number;
      /** @description The system this game is for. */
      system_id: components["schemas"]["SystemRef"];
      /**
       * Format: int32
       * @description The identifier for the game, in this system. This is unique for all games in this system.
       */
      system_unique_id: number;
      /** @description The checksums and sizes of all artifacts the game. */
      artifacts: components["schemas"]["ArtifactRef"][];
    };
    /** @description Parameters for filtering the list of games using checksums. */
    GameListBody: {
      /** @description Filter by md5 checksum. */
      md5?: components["schemas"]["HexString"][] | null;
      /** @description Filter by sha1 checksum. */
      sha1?: components["schemas"]["HexString"][] | null;
      /** @description Filter by sha256 checksum. */
      sha256?: components["schemas"]["HexString"][] | null;
    };
    /** @description Parameters for a range of integers. */
    RangeParams_for_int32: {
      from: components["schemas"]["Bound_of_int32"];
      to: components["schemas"]["Bound_of_int32"];
    };
    Bound_of_int32: OneOf<[{
      /** Format: int32 */
      Included: number;
    }, {
      /** Format: int32 */
      Excluded: number;
    }, "Unbounded"]>;
    GameUpdateRequest: {
      name?: string | null;
      description?: string | null;
      short_description?: string | null;
      /** Format: int32 */
      year?: number | null;
      publisher?: string | null;
      developer?: string | null;
      add_links?: {
        [key: string]: string;
      } | null;
      remove_links?: string[] | null;
      /** Format: int32 */
      system_unique_id?: number | null;
    };
    UserDetails: {
      teams: components["schemas"]["UserTeamRef"][];
      /** Format: int32 */
      id: number;
      username: string;
      description: string;
      links: unknown;
      metadata: unknown;
    };
    UserTeamRef: {
      role: components["schemas"]["UserTeamRole"];
      /** Format: int32 */
      id: number;
      name: string;
      slug: string;
    };
    /** @enum {string} */
    UserTeamRole: "owner" | "admin" | "member";
    /** @description A JWT authentication token. */
    AuthTokenResponse: {
      /** @description The token itself. */
      token: string;
    };
    /** @description Parameters for updating a user. */
    UserUpdate: {
      username?: string | null;
      display_name?: string | null;
      description?: string | null;
      links?: {
        [key: string]: string;
      } | null;
      metadata?: {
        [key: string]: unknown;
      } | null;
      add_links?: {
        [key: string]: string;
      } | null;
      remove_links?: string[] | null;
    };
    /** @description Parameters for creating a new platform. */
    PlatformCreateResponse: {
      /**
       * Format: int32
       * @description The ID of the new platform created.
       */
      id: number;
      /** @description The slug of the platform. */
      slug: string;
    };
    /** @description Parameters for creating a new platform. */
    PlatformCreateRequest: {
      /** @description A slug for the platform. Must be unique to all platforms. */
      slug: string;
      /** @description The human-readable name of the platform. */
      name: string;
      /** @description A description of the platform. */
      description: string;
      /** @description Links to the platform's website, documentation, etc. */
      links?: {
        [key: string]: string;
      } | null;
      /** @description Metadata for the platform. No schema is enforced. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /** @description The team id who will own the platform. The user must be a member of the team. */
      owner_team: components["schemas"]["IdOrSlug"];
    };
    PlatformDetails: {
      /** Format: int32 */
      id: number;
      slug: string;
      name: string;
      description: string;
      links: unknown;
      metadata: unknown;
      owner_team: components["schemas"]["TeamRef"];
    };
    Platform: {
      /** Format: int32 */
      id: number;
      slug: string;
      name: string;
    };
    /** @description Parameters for updating a platform's information. */
    PlatformUpdateRequest: {
      /** @description A slug for the platform. Must be unique to all platforms. */
      slug?: string | null;
      /** @description The human-readable name of the platform. */
      name?: string | null;
      /** @description A description of the platform. */
      description?: string | null;
      /** @description Links to the platform's website, documentation, etc. */
      links?: unknown;
      /** @description Metadata for the platform. No schema is enforced. */
      metadata?: unknown;
      /**
       * Format: int32
       * @description The team id who will own the platform. The user must be a member of the team.
       */
      team_id?: number | null;
    };
    SystemCreateResponse: {
      /** Format: int32 */
      id: number;
      slug: string;
    };
    SystemCreateRequest: {
      slug: string;
      name: string;
      description: string;
      manufacturer: string;
      links?: {
        [key: string]: string;
      } | null;
      metadata?: {
        [key: string]: unknown;
      } | null;
      owner_team: components["schemas"]["IdOrSlug"];
    };
    SystemDetails: {
      /** Format: int32 */
      id: number;
      slug: string;
      name: string;
      description: string;
      manufacturer: string;
      links: {
        [key: string]: string;
      };
      metadata: {
        [key: string]: unknown;
      };
      owner_team: components["schemas"]["TeamRef"];
    };
    SystemListItem: {
      /** Format: int32 */
      id: number;
      slug: string;
      name: string;
      manufacturer: string;
      owner_team: components["schemas"]["TeamRef"];
    };
    Tag: {
      /** Format: int32 */
      id: number;
      /** @description The slug of the tag. */
      slug: string;
      /**
       * Format: uint32
       * @description An RGB color. The top 8 bits are ignored.
       */
      color: number;
    };
    TagCreate: {
      slug: string;
      description: string;
      /**
       * Format: uint32
       * @description An RGB color. The top 8 bits are ignored.
       */
      color: number;
    };
    TeamInvite: {
      user: components["schemas"]["UserIdOrUsername"];
      /** @default member */
      role?: components["schemas"]["UserTeamRole"];
    };
    /** @description A user ID can be either an User ID (as an integer) or a username string. */
    UserIdOrUsername: number | components["schemas"]["Username"];
    /** @description A valid username (not empty, not too long, no special characters). */
    Username: string;
    Team: {
      description: string;
      links: unknown;
      metadata: unknown;
      /** Format: int32 */
      id: number;
      name: string;
      slug: string;
    };
    /** @description Response when creating a team. */
    TeamCreateResponse: {
      /** Format: int32 */
      id: number;
      slug: string;
    };
    /** @description Arguments to create a team. */
    TeamCreateRequest: {
      /** @description A slug for the team. */
      slug: string;
      /** @description A name for the team. */
      name: string;
      /** @description The description of the team. */
      description: string;
      /** @description Links to the team's various aspects. */
      links?: {
        [key: string]: string;
      } | null;
      /** @description Generic metadata associated with the team. */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    TeamDetails: {
      description: string;
      links: {
        [key: string]: string;
      };
      metadata: {
        [key: string]: unknown;
      };
      users: components["schemas"]["TeamUserRef"][];
      /** Format: int32 */
      id: number;
      name: string;
      slug: string;
    };
    TeamUserRef: {
      role: components["schemas"]["UserTeamRole"];
      /** Format: int32 */
      id: number;
      username: string;
    };
    /** @description Arguments to create a team. */
    TeamUpdateRequest: {
      /** @description A slug for the team. */
      slug?: string | null;
      /** @description A name for the team. */
      name?: string | null;
      /** @description The description of the team. */
      description?: string | null;
      /** @description Replace all links in the team. */
      links?: {
        [key: string]: string;
      } | null;
      /** @description Replace all metadata associated with the team. */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /** @description Add new links to the list. If the `links` key is also passed, this is ignored. */
      add_links?: {
        [key: string]: string;
      } | null;
      /** @description Remove links from the list. */
      remove_links?: string[] | null;
    };
    /** @description Response when asking for the availability of a username. */
    UserCheckResponse: {
      username: string;
      available: boolean;
    };
    /** @description A User information. */
    User: {
      /**
       * Format: int32
       * @description The user id.
       */
      id: number;
      /** @description The username. If missing, the user has no username and must set its username before being able to make changes. */
      username?: string | null;
      /** @description The user's avatar. */
      avatar_url?: string | null;
      /** @description The user's display name. */
      display_name?: string | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * @description Login using GitHub with OAuth2. This will redirect the user to GitHub's login page. If the user accepts the request, GitHub will redirect the user back to the callback URL specified in the OAuth2 configuration.
   *
   * This is not a REST endpoint, but a normal web page.
   */
  auth_github_login: {
    responses: {
      500: {
        content: never;
      };
    };
  };
  /**
   * @description Login using Google with OAuth2. This will redirect the user to GitHub's login page. If the user accepts the request, GitHub will redirect the user back to the callback URL specified in the OAuth2 configuration.
   *
   * This is not a REST endpoint, but a normal web page.
   */
  auth_google_login: {
    responses: {
      500: {
        content: never;
      };
    };
  };
  /** @description Login using Patreon with OAuth2. */
  auth_patreon_login: {
    responses: {
      500: {
        content: never;
      };
    };
  };
  /** @description Logout the current user. */
  auth_logout: {
    responses: {
      500: {
        content: never;
      };
    };
  };
  /** @description List cores. */
  cores_cores_list: {
    parameters: {
      query?: {
        /** @description Filter cores by supported platform. By default, include all cores. */
        platform?: components["schemas"]["IdOrSlug"];
        /** @description Filter cores by system. By default, include all systems. */
        system?: components["schemas"]["IdOrSlug"];
        /** @description Filter cores by owner team. By default, include all teams. */
        owner_team?: components["schemas"]["IdOrSlug"];
        /** @description Filter by latest release date. By default, include all cores. */
        release_date_ge?: number | null;
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CoreListItem"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  cores_cores_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CoreCreateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CoreCreateResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  cores_cores_details: {
    parameters: {
      path: {
        core_id: components["schemas"]["IdOrSlug"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CoreDetailsResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Get a release's artifact list, including everything except the data itself. */
  cores_releases_cores_releases_artifacts_list: {
    parameters: {
      query?: {
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
      };
      path: {
        core_id: components["schemas"]["IdOrSlug"];
        release_id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CoreReleaseArtifactListItem"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Upload an artifact to a release. This can be done multiple times. The upload will be refused if the user does not have permission to upload artifacts to the release's core. */
  cores_releases_cores_releases_artifacts_upload: {
    parameters: {
      header: {
        "Content-Type": string;
      };
      path: {
        core_id: components["schemas"]["IdOrSlug"];
        release_id: number;
      };
    };
    requestBody: {
      content: {
        "application/octet-stream": number[];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ArtifactCreateResponse"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  cores_releases_cores_releases_list: {
    parameters: {
      query?: {
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
        /** @description Whether to include prereleases in the results. Defaults to false. */
        prerelease?: boolean | null;
        /** @description Whether to include yanked releases in the results. Defaults to false. */
        yanked?: boolean | null;
        /** @description Minimum date to include in the results, in seconds since UNIX EPOCH. Defaults to 0 (all releases). */
        min_release_date?: number | null;
        /** @description Maximum date to include in the results, in seconds since UNIX EPOCH. Defaults to i64::MAX (all releases). */
        max_release_date?: number | null;
        /** @description Filter releases by platform. By default, include all platforms. */
        platform?: components["schemas"]["IdOrSlug"];
      };
      path: {
        core_id: components["schemas"]["IdOrSlug"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CoreReleaseListItem"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Create a release for a core. This does not include any artifacts, which must be uploaded separately. */
  cores_releases_cores_releases_create: {
    parameters: {
      path: {
        core_id: components["schemas"]["IdOrSlug"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CoreReleaseCreateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CoreReleaseCreateResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  games_games_add_artifact: {
    parameters: {
      path: {
        game_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GameAddArtifactRequest"][];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  games_games_list: {
    parameters: {
      query?: {
        /** @description Filter games by system. By default, include all systems. */
        system?: components["schemas"]["IdOrSlug"];
        /** @description Filter by year. */
        year?: components["schemas"]["RangeParams_for_int32"];
        /** @description Filter by name, exact substring. If both name and exact_name are specified, they will both try to match and may give no result. */
        name?: string | null;
        /** @description Filter by name, exact. If both name and exact_name are specified, they will both try to match and may give no result. */
        exact_name?: string | null;
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GameListBody"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GameListItemResponse"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  games_games_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GameCreateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GameCreateResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  games_games_details: {
    parameters: {
      path: {
        game_id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GameDetails"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  games_games_update: {
    parameters: {
      path: {
        game_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GameUpdateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  me_me: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UserDetails"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Create a JWT token for the current logged-in user. */
  me_me_token: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AuthTokenResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  me_me_update: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  platforms_platforms_list: {
    parameters: {
      query?: {
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Platform"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  platforms_platforms_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PlatformCreateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PlatformCreateResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  platforms_platforms_details: {
    parameters: {
      path: {
        platform_id: components["schemas"]["IdOrSlug"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PlatformDetails"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  platforms_platforms_update: {
    parameters: {
      path: {
        platform_id: components["schemas"]["IdOrSlug"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PlatformUpdateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  systems_systems_list: {
    parameters: {
      query?: {
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SystemListItem"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  systems_systems_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SystemCreateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SystemCreateResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  systems_systems_details: {
    parameters: {
      path: {
        id: components["schemas"]["IdOrSlug"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SystemDetails"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description List tags. */
  tags_tags: {
    parameters: {
      query?: {
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Tag"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Create or update a tag. */
  tags_tags_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagCreate"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Get a tag information (including its description). */
  tags_tags_delete: {
    parameters: {
      path: {
        tag_id: components["schemas"]["IdOrSlug"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  teams_invite: {
    parameters: {
      path: {
        team_id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TeamInvite"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  teams_invite_accept: {
    parameters: {
      path: {
        team_id: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  teams_teams: {
    parameters: {
      query?: {
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Team"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Create a new team, and make the current user its owner. */
  teams_teams_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TeamCreateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamCreateResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Create a new team, and make the current user its owner. */
  teams_teams_update: {
    parameters: {
      path: {
        team_id: components["schemas"]["IdOrSlug"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TeamUpdateRequest"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  teams_teams_delete: {
    parameters: {
      path: {
        team_id: components["schemas"]["IdOrSlug"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  teams_teams_details: {
    parameters: {
      path: {
        id: components["schemas"]["IdOrSlug"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["TeamDetails"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Check availability of a username. This is easier and less resource intensive than getting the user's details and checking for 404. */
  users_check_username: {
    parameters: {
      query: {
        username: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UserCheckResponse"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description List all users. */
  users_users: {
    parameters: {
      query?: {
        /** @description The page index to retrieve. The first page is 0. This will multiply by the limit to get the actual item offset. Defaults to 0. */
        page?: number | null;
        /** @description The maximum number of items to retrieve. Must be between 10 and 100. Defaults to 20. */
        limit?: number | null;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["User"][];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  users_users_details: {
    parameters: {
      path: {
        id: components["schemas"]["UserIdOrUsername"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UserDetails"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** @description Only root users can update other users. */
  users_users_update: {
    parameters: {
      path: {
        id: components["schemas"]["UserIdOrUsername"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      default: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
}
